# 外观模式（门面模式）的标准实现@Java
![image](https://user-images.githubusercontent.com/64548919/131222666-57a95003-d01e-4155-9a21-89fe80a06b42.png)
## 1. 为什么要学习外观模式？
有时候，一个系统的完整调度需要涉及好几个子系统的共同协同工作，共同协作调度过程极为复杂。      
这时候，外观模式就能够将复杂的协同工作聚合起来，将系统的复杂性对上层屏蔽处理，而仅仅需要调用一个自定义接口即可完成所有工作。      
## 2. 外观模式能够解决哪些问题？
外观模式可以将好几个子系统进行集成，将子系统的调用过程简化处理。      
      
## 3. 外观模式有哪些核心步骤？
核心步骤：     
1. 定义一个Facade类，封装多个子系统的成员变量；      
2. 在Facade类中定义对外开放的接口方法，并规定这几个子系统的调度先后顺序；     
3. 外部客户端在调用子系统集成的时候，直接调用Facade的对外接口即可。      

## 4. 外观模式有哪些优缺点？
优点：       
1. 外观模式可以减少子系统之间的耦合度，使得子系统变化不会影响外部调用的客户端；       
2. 对上层客户端直接屏蔽底层实现细节，使得调用多个子系统的流程简单化；      
3. 外观模式可以预防低水平开发人员对系统造成的破坏。      

缺点：      
1. 外观模式违反了“开闭原则”，如果需求有发生实际的变动，那么外观模式的设计就必须修改原有的代码；       
2. 外观模式底层实现细节对上层用户屏蔽，从而不方便控制用户端的权限访问，可能带来风险。       
## 5. 外观模式和工厂模式有哪些异同点？
先回顾这几个模式的基本概念：        
### 5.1 外观模式
结构型模式       
作用：简化用户调度子系统的程序流程      
环境：为相对独立的多个子系统提供外部访问接口       
实现方法：调用客户端和多个子系统之间添加门面层（Facade）        

### 5.2 工厂模式
创建型模式      
作用：解决接口的多态化实现的选择问题        
环境：需要得到同一接口的不同具体实现形式       
实现方法：定义工厂类，接受字符串等对象，将创建过程延迟到子类实现      

从二者的定义，我们就可以发现异同点：       
### 相同点
1. 都是提供允许外部调用的接口，将复杂的流程简单化，抽象化；       
2. 都不太符合“开闭原则”，如果功能需要变动，则需要修改原本的代码；         

### 不同点
1. 外观模式是结构型模式，更加偏重类对象之间的组合与功能调度；而工厂模式则是创建型模式，更加侧重于符合要求的对象的创建；       
2. 实现细节上有所不同，如外观模式上的门面层直接封装了子系统供调用；而工厂模式则需要if-else判断来实现多态对象的创建。
