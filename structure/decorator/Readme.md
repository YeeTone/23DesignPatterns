# 你以为你换套衣服我就认不出你？ --装饰器模式的标准实现@Java
![image](https://user-images.githubusercontent.com/64548919/131221569-efa051fe-65a1-46dc-b1fd-5807d4ab11f5.png)
## 1. 为什么要学习装饰器模式？
有时候，我们对于现成已有的对象需要添加一些额外的功能而不影响其他原有的功能。     
当然，继承是一种可以实现这个需求的手段，但并非最优解。      
这是因为面向对象的语言中，Java，C#等不支持多重继承，而像C++，Python等支持多重继承的语言也对多重继承不提倡，会使得代码逻辑混乱，类关系复杂。      
如果需要原有类的特征，同时又要继承其他类，继承就不是很好的选择，会让类之间耦合关系增强，不利于代码可扩展性的增加。       
    
装饰器模式提供了一种易于对已有类增加和扩展的设计模式，同时无需改变其原有的功能。      
相较于继承而言，装饰器可以动态添加/变更职责，更加灵活。 

## 2. 装饰器模式能解决什么问题？
装饰器模式主要可以解决在原有类基础功能不发生大变动的条件下，往其中增加或修改少部分功能的生产问题。

## 3. 装饰器模式有哪些核心步骤？
核心步骤：     
1. 定义一个抽象接口Component和一个抽象类Decorator；       
2. Decorator抽象类实现Component接口（可以用抽象方法延迟实现）并封装Component对象；     
3. 所有具体类对象继承Decorator类和实现Component接口；      
4. 具体的多态实现交给具体的类对象进行实例处理。      

## 4. 装饰器模式有哪些优缺点？
优点：     
1. 装饰器模式易于扩展，需要增加功能就增加一个装饰器类就好了，符合开闭原则；     
2. 装饰器模式可以动态扩展，可以降低类与类之间的耦合度；     

缺点：     
1. 如果功能变动频繁，那么需要的装饰器类个数就会很多，导致系统复杂化；     
2. 如果装饰器类被多次修饰，则会导致类的行为追踪复杂，不利于程序问题的定位。
