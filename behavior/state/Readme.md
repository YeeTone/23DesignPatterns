# 行为决定状态，状态对行为有反作用 --状态模式的标准实现@Java
![image](https://user-images.githubusercontent.com/64548919/131494889-f9aad15b-06ad-4281-9340-99c047f9fe15.png)
## 1. 为什么要学习状态模式？
有时候，应用程序的对象在不同的时空环境可能具有不同的状态，从而表现出不同的行为。       
这种可变性可能使得多种行为大相径庭，甚至从外部看起来，类对象的类型都发生了更换。        

在传统的设计结构中，我们的做法是将状态进行表示，然后使用if-else分支来做状态判断和分支处理；       
但这种设计从软件结构的角度来说，无疑十分糟糕，使得条件判断分支过于臃肿，且可读性糟糕，不易扩展，维护难度大；           
如果需要增加新的状态判定，那么就需要修改if-else的分支代码，违背了“开闭原则”，扩展性很糟糕。       

但是，如果我们换一种思路来思考就能解决这一问题：                
应用程序的状态变化和类与对象的多态有一定相似性，如果我们使用接口的多态实现来表示状态并执行多样化的操作，            
那么编译器就可以帮我们完成对象状态的判断和对应操作的执行，从而回避if-else的条件判断，使得代码可扩展性大大增强。

上面说的这些，就是状态模式的基本实现流程，也是对“为什么要学习状态模式”这一问题最好的回答。

## 2. 状态模式能解决什么问题？
状态模式主要可以解决对象需要根据状态来执行多种操作的具体实现问题。       
此外，功能的实现代码如果包含大量和对象状态有关的条件语句，那么使用状态模式就能对臃肿的代码做较好的重构处理。      

## 3. 状态模式有哪些必须的实现步骤？
必须实现步骤：      
1. 定义抽象状态抽象类或者接口，其中定义一个方法，来实现多种操作的多态处理；       
2. 定义具体状态继承或实现抽象状态类，将多个条件分值判断放到多个具体实现类的方法中；        
3. 定义环境类，其中封装抽象状态对象，定义状态切换方法和提供给用户多种功能的接口。       

## 4. 状态模式有哪些优缺点？
优点：       
1. 结构清晰，通过接口的多态实现来完成状态的分支判断，满足“单一职责原则”；         
2. 状态转换显式化，减少对象之间的相互依赖；       
3. 易于扩展，如果需要增加新的状态，那么增加新的状态类的子类实现类即可；         

缺点：      
1. 状态模式使得类的个数膨胀，增加了系统类与对象的个数，使得系统复杂化；        
2. 状态模式的结构和实现都比较复杂，有可能导致逻辑混乱 **（没想清楚怎么转换状态就最好先不要动手写状态模式）**；
3. 相较于以往的传统if-else分支，虽然状态模式在“开闭原则”的支持有所改进，但仍然不太理想：在增加新的状态类的时候，需要修改状态转换部分的源码。      


## 5. 状态模式和策略模式有哪些异同点？
相同点：        
1. 状态模式和策略模式的设计图纸高度相似，是孪生兄弟；         
2. 状态模式和策略模式都是将不同的处理情形向上抽象为接口，尽可能符合“开闭原则”；      

不同点：        
1. 状态模式侧重于状态的切换而做不同的事情；策略模式并不涉及切换，而是具体情况具体分析，做出决策；         
2. 状态模式是状态到了一定条件就会发生转换，不由用户控制，用户最多可以设置初始状态；策略模式让用户可以在指定的算法实现中做选择；       
