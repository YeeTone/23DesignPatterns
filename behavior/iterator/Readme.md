# 流水线上走一遭，每个包裹扫一遍 --迭代器模式的标准实现@Java
![image](https://user-images.githubusercontent.com/64548919/131357802-a4b8faa4-71d6-41f7-b38a-1f141531819c.png)
## 1. 为什么要学习迭代器模式？
之前，我们学过了链式结构的责任链模式。它可以顺序执行流程的访问过程，而无需得知具体完整的每个环节的每个细节。         
但这个存在一些问题，一方面每次都需要从链表头开始请求，访问效率会受到一定的损失；另一方面有可能会暴露内部表示细节，数据安全性有损失。                
迭代器模式解决了这一问题，可以顺序访问集合对象当中的元素，而无需关心集合对象的底层实现细节。        
**（也就是说，即使底层数据结构的实现并非链表，也可以实现集合对象的顺序访问！）**

## 2. 迭代器模式能解决什么问题？
迭代器模式可以实现非底层链表结构的顺序访问，提供了多种方式来对集合元素进行遍历。

## 3. 迭代器模式的标准实现步骤有哪些？
1. 定义容器，内部能够实现对元素的存储，单次访问的复杂度最好是O(1)       
（底层最好不要用java自带的链表，因为每次get方法都要从链表的某一端访问，时间复杂度是O(n)）；      
2. 定义迭代器接口，内部定义hasNext方法和next方法；      
3. 将迭代器接口实例化，内部封装index以确定访问元素位置；     
4. hasNext方法通过index与容器元素个数的比较来确定结果；       
next方法先调用hasNext方法检查，如果有就调整index并返回元素，否则就返回null。
## 4. 迭代器模式有哪些优缺点？
优点：    
1. 对底层实现不是链表的数据集成对象提供了顺序访问接口，使得遍历集合的方式多样化；       
2. 对不同的集合结构都有较好的支持，不依赖于集合具体实现；        
3. 遍历过程可以交给迭代器，简化了集合类的具体实现；      
4. 增加扩展集合类和迭代器类都很方便，符合“开闭原则”；      

缺点：      
1. 迭代器模式将集合体系中的遍历功能抢了过来，使得如果要增加新的集合结构，就需要增加新的迭代器类，使得类的个数成倍增加，增加了系统结构的复杂性；       
