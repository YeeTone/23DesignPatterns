# 命令模式的标准实现@Java
![image](https://user-images.githubusercontent.com/64548919/131321145-38392fe7-cbe8-412a-ad85-c8512f144f23.png)
## 1. 为什么要学习命令模式？
在先前的设计模式介绍中，我们一般对于一个方法的执行分为了两个部分：请求者和执行者。        
这不一定是一个最优的设计模式，因为这使得这两部分对象构成了紧密的耦合关系，使得方法的特殊执行过程不易控制，如“重做”、“记录”、“撤销”等等。        
         
命令模式能够将对象的执行模式抽象出来，将执行的过程也变为对象的形式进行控制。         
命令模式使得方法的请求者和执行者解耦，将请求者和执行者的责任分离开来。       
在这个过程中，由执行命令抽象出来的对象就成了请求者和执行者沟通的唯一桥梁。        
这也就意味着方法的执行体系由“请求者-执行者”变化为“请求者-命令对象-执行者”。         

## 2. 命令模式能解决什么问题？
面对命令的执行过程本身需要进行一些操作（如记录，撤销，重做等等）的时候，命令模式能够灵活地满足这种需求。

## 3. 命令模式有哪些标准实现步骤？
标准实现步骤：        
1. 定义Receiver对象，这个对象是方法体的执行者；      
2. 定义Invoker对象，这个对象是方法体的请求者；       
3. 定义Command抽象接口，然后书写多个具体多态实现该接口，其中具体实现必须封装Receiver对象；      
4. 具体实现类中直接调用Receiver的对应方法，减少其中可能的额外操作。      


## 4. 命令模式有哪些优缺点？
优点：        
1. 引入中间命令层，将方法体的执行过程也抽象为对象，可以降低系统耦合度；        
2. 扩展性良好，对命令的定义，修改，删除都非常方便，不会影响其他类对象；       
3. 有利于对方法执行过程的特殊化操作，如记录等等；       
4. 命令模式可以结合多种其他设计模式进一步升级，如装饰器模式等等；       

缺点：       
1. 对于每一种具体操作，都需要一个相对应的命令类，使得系统类的个数成倍增长，复杂性增加；       
2. 命令模式增加的中间抽象层，使得系统的理解难度相应增加 **（设计模式都学到现在了，难道还没意识到都是这么玄学的吗！）**
