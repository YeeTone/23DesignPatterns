# 世上只有一个我 --单例模式的标准实现@Java
## 1. 为什么要学习单例模式？
有时候，对象的创建会极其耗费系统资源，如：    
1. 封装巨大数组对象的创建；     
2. 数据库连接池的创建；    
3. 文件I/O流读取的创建；    
    
这时候，对象的频繁创建与销毁就会耗费大量的资源。而单例模式就有助于控制一个类的实例对象的数目，大大有利于节约系统资源。    
## 2. 单例模式能解决什么问题？
可以解决一个类的实例变量需要多次被使用的情形。使用单例模式有利于节约系统资源和减轻垃圾回收的负担。    
## 3. 单例模式的实现有哪几种方法？它们的特点各是什么？
有6种方法，**其共有的特点是构造方法使用private修饰符进行私有化**    
1. 饿汉式：    
ClassLoader加载时就完成了对象的实例化，实现简单且线程安全（这是由于ClassLoader进行类加载这个行为是线程安全的），但消耗资源；    
2. 单线程懒汉式：        
不先初始化对象，等到要用的时候才初始化。单线程可用，但多线程会出错，这是源于这个方法没有控制线程安全。    
3. 多线程synchronized懒汉式：    
单/多线程均可用，但是由于synchronized对方法体加锁，效率会有损失。    
4. 多线程双重校验锁懒汉式：    
单/多线程均可用，由于对象的new实例化操作并非原子操作，需要用synchronized关键字控制线程安全，用volatile关键字禁止指令重排。    
这样在多线程条件下也可以保证较高的性能，是比较推荐的单例模式实现方法。    
5. 多线程静态登记内部类懒汉式：    
利用ClassLoader对静态内部类的加载机制（是线程安全的），延迟实例对象的创建时间。这种实现更加简单，也具有很好的性能。    
6. 枚举实现单例：    
**综合来看，这是最佳的单例实现策略。**     
这种方法在各个方面都保证绝对安全，如阻止反射攻击创建实例对象（方法1-5都无法防止）、阻止通过反序列化机制创建对象、阻止线程不安全带来的多次对象实例化。     
不过这种方法也有缺点，首先无法继承，其次由于枚举的特性，枚举对象无法延迟加载，导致内存消耗比饿汉模式还要多。     
