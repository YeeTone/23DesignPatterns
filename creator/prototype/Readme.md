# 拔一根猴毛，吹出千万个 --原型模式的标准实现@Java
![image](https://user-images.githubusercontent.com/64548919/130764537-2fe2e14f-b16d-4114-afde-495788cbaf74.png)

## 1. 为什么要学习原型模式？
有时候，通过new关键字来实现**相同或相似**对象的创建会极其耗费资源，如：     
1. 从数据库拿取相同信息的对象；     
2. 从文件I/O流读取图片等等复杂对象；   
     
但类对象的副本又需要多次使用，如果反复通过new关键字进行初始化会导致时空两个维度上的浪费。原型模式提供了一种基于内存二进制流的复制的策略来创建副本对象，有利于高效地处理问题。    
## 2. 原型模式能解决什么问题？
能够解决同等信息对象副本的快速简易创建问题，可以快速获取副本对象。     
## 3. 原型模式的实现有哪几个关键步骤？
1. 抽象类重载父类Object的clone方法并自定义实现，将权限设置为public。其中内部嵌套对象是否也需要clone来实现深克隆，这个需要具体问题具体分析（大部分情况都是需要深克隆）。       
2. 定义Cache类封装Map数据结构用于缓存对象到内存中，实现快速获取对象；    
3. 获取对象时，如果Cache中有对应对象（缓存命中），那么就直接拿取对象的clone副本；否则就去寻找对应的对象然后放入Map中。   

## 4. 原型模式有什么样的应用场景？
1. 对象之间相同或相似，即只是个别的几个属性不同的时候。    
2. 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。     
3. 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。     
4. 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。     
